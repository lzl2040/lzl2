---
layout: post
title:  LeetCode日志
date:   2020-12-22 12:17:11 +0530
categories: 算法设计 LeetCode
---
-------------------2020-12-22----------------------------  
  
今天是LeetCode刷题的第二天，心态已经被搞炸，简单题也这么难的吗？呜呜，还是自己太菜了

## 无重复字符的最长字串
给定一个字符串，请你找出其中不含有重复字符的 最长子串的长度。  
```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
解题思路：其实这题不是很难，在做此题的时候目标也很明确，遍历无重复字符字串(start-end)，找出是否有与新加进来的字符(ch)相等的地方  
做此题时，问题主要出在start在发现有重复字串后的取值为多少，以及count的值  
代码如下：  

```cpp
int lengthOfLongestSubstring(char * s){
    	int l = strlen(s);
        if(l==0)
        return 0;
        char ch;
	int start = 0,end=0,count = 0,maxL = 0,i;
	while(start<l&&end<l)
	{
		ch = s[end];
		for(i=start;i<end;i++)
		{			
			if(ch==s[i])//出现相等则重新开始 
			{
				start = i + 1;
				count = end-start;
				break;
			}
		}
		count++;//没有相同的地方则长度+1 
		end++;
		if(maxL<count)
			maxL = count;
	}
    return maxL;
}
```


-------------------2020-12-25----------------------------  
时隔多天，我胡汉三又回来了！！！今天要说的时一道很经典的题目，最大子序列，这是一道挺经典的动态规划题  
## 最长子序列
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。  
```
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```
解题思路：最开始想到的肯定是循环嵌套，这种很容易想到，但时间复杂度很大，数组长度很大就很容易超时。这种一般情况下不采用这方法。  
这可以看成是一个动态规划题目，当子序列和f[i-1]<0时，若它再加上一个nums[i],只会使f[i]更小,故此时f[i]=nums[i];当子序列和f[i-1]>=0时,  
再加上nums[i],只会让nums[i]更大，则f[i]=f[i-1]+nums[i]。由此得到状态转换方程。有人可能会有疑惑，如果nums[i]也小于0呢，f[i]不是会更  
小吗，事实的确时这样，但我们最后是要在f[0]-f[numSize]中找最大值的，那个变得更小没有关系。  
代码：  
```cpp
int max(int a,int b)
{
    return (a>b)?a:b;
}
int maxSubArray(int* nums, int numsSize){
        int f[1001],mid=nums[0],ans=nums[0];//防止其只有一个元素
        f[0]=nums[0];
	for(int i=1;i<numsSize;i++)
	{
		mid = (mid>0)?(mid+nums[i]):nums[i];
		ans = max(mid,ans);//找到最大的
	}	
    return ans;
}
```

-------------------2020-12-26----------------------------  
今天带来的还是一道动态规划题，这题的重点是找出状态转移方程
## 按摩师
一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。  
```
输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。
```
解题思路：本题我们发现接下后一个预约的总时间与之前的总时间是有关系的，若本次不按摩，则dp[i]=dp[i-1] || dp[i-2] ....,这说明要得到后面的就需要借助前面的数据,
而动态规划正是将大问题分解成小问题，先求之前的最优解，然后得到目标值的最优解。接着上面的，若本次按摩了，则dp[i]=dp[i-2]+nums[i],说明总时间是等于上次(没有与本次相邻)
的总时间加上本次的时间。我们要求的是这两种情况的最大值，则有状态转移方程：dp[i]=max(dp[i-1],dp[i-2]+nums[i])。  
代码如下：
```cpp
int max(int a,int b)
{
	return (a>b)?a:b;
}
int dp[100001],i;
int massage(int* nums, int numsSize){
    if(numsSize==0)
        return 0;
    if(numsSize==1)
        return nums[0];
    
    memset(dp,0,sizeof(dp));
    dp[0]=nums[0];//最开始是0
	dp[1]=max(nums[0],nums[1]);
	for(i=2;i<numsSize;i++)
	{
		dp[i]=max(dp[i-1],dp[i-2]+nums[i]);//dp[i-1]前一次按了摩,dp[i-2]这次没有 
	} 
    return dp[numsSize-1];
}
```
 