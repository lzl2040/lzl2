---
layout: post
title:  LeetCode日志
date:   2020-12-22 12:17:11 +0530
categories: 算法设计 LeetCode
---
-------------------2020-12-22----------------------------  
  
今天是LeetCode刷题的第二天，心态已经被搞炸，简单题也这么难的吗？呜呜，还是自己太菜了

## 无重复字符的最长字串
给定一个字符串，请你找出其中不含有重复字符的 最长子串的长度。  
```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
解题思路：其实这题不是很难，在做此题的时候目标也很明确，遍历无重复字符字串(start-end)，找出是否有与新加进来的字符(ch)相等的地方  
做此题时，问题主要出在start在发现有重复字串后的取值为多少，以及count的值  
代码如下：  

```cpp
int lengthOfLongestSubstring(char * s){
    	int l = strlen(s);
        if(l==0)
        return 0;
        char ch;
	int start = 0,end=0,count = 0,maxL = 0,i;
	while(start<l&&end<l)
	{
		ch = s[end];
		for(i=start;i<end;i++)
		{			
			if(ch==s[i])//出现相等则重新开始 
			{
				start = i + 1;
				count = end-start;
				break;
			}
		}
		count++;//没有相同的地方则长度+1 
		end++;
		if(maxL<count)
			maxL = count;
	}
    return maxL;
}
```


-------------------2020-12-25----------------------------  
时隔多天，我胡汉三又回来了！！！今天要说的时一道很经典的题目，最大子序列，这是一道挺经典的动态规划题  
## 最长子序列
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。  
```
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```
解题思路：最开始想到的肯定是循环嵌套，这种很容易想到，但时间复杂度很大，数组长度很大就很容易超时。这种一般情况下不采用这方法。  
这可以看成是一个动态规划题目，当子序列和f[i-1]<0时，若它再加上一个nums[i],只会使f[i]更小,故此时f[i]=nums[i];当子序列和f[i-1]>=0时,  
再加上nums[i],只会让nums[i]更大，则f[i]=f[i-1]+nums[i]。由此得到状态转换方程。有人可能会有疑惑，如果nums[i]也小于0呢，f[i]不是会更  
小吗，事实的确时这样，但我们最后是要在f[0]-f[numSize]中找最大值的，那个变得更小没有关系。  
代码：  
```cpp
int max(int a,int b)
{
    return (a>b)?a:b;
}
int maxSubArray(int* nums, int numsSize){
        int f[1001],mid=nums[0],ans=nums[0];//防止其只有一个元素
        f[0]=nums[0];
	for(int i=1;i<numsSize;i++)
	{
		mid = (mid>0)?(mid+nums[i]):nums[i];
		ans = max(mid,ans);//找到最大的
	}	
    return ans;
}
```